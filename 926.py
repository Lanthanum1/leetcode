class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        # 最终的状态必然是某分界点之前全是 0 ，该分界点后全是 1
        # 遍历分界点，统计前面的 1 与后面 的 0 之和
        sm = s.count('0')
        ans = [sm]
        # 一开始分界指针放到整个数组的前面，分界点前面没有 1，分界点后面 0 的个数就是 整个数组 0 的个数
        for c in s:
            if c == '0': # 如果当前的数是 0，那么前面的 1 的个数 不会改变，但是 0 的总数不变，当前是 0 ，那么后面的 0 的个数就少了，前面的 1 与后面 的 0 之和也就少了
                sm -= 1
            else: # 如果当前的数是 1，那么前面的 1 的个数 加一，后面 0 的个数不变，前面的 1 与后面 的 0 之和加一
                sm += 1
            ans.append(sm)
        return min(ans)